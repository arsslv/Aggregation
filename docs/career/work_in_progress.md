## **1. Основные обязанности системного аналитика** 

### **Глоссарий**

- **BPMN (Business Process Model and Notation)** — международный стандарт графической нотации для моделирования бизнес-процессов в виде понятных диаграмм;
- **BRD (Business Requirements Document)** — документ, который описывает высокоуровневые бизнес-цели, проблемы и ожидания от проекта, отвечая на вопрос «Зачем?»;
- **EPC (Event-Driven Process Chain)** — нотация для моделирования бизнес-процессов, где акцент делается на последовательности событий и функций;
- **ER-диаграмма (Entity-Relationship diagram)** — графическая модель, которая показывает сущности предметной области (например, «Заказ», «Клиент»), их атрибуты и связи между ними;
- **Mockup** — статичное, более детализированное изображение интерфейса, которое демонстрирует визуальный дизайн, цвета и типографику, но без интерактивности;
- **SRS (Software Requirements Specification) / FRS (Functional Requirements Specification)** — детальный документ, описывающий функциональные и нефункциональные требования к системе, её поведение и интерфейсы;
- **UAT (User Acceptance Testing)** — финальная фаза тестирования, где реальные пользователи проверяют, соответствует ли готовый продукт их потребностям и бизнес-требованиям, перед запуском.
- **Use Case** — описание последовательности действий системы для выполнения конкретной цели пользователя, включая основные и альтернативные сценарии;
- **User Story** — краткое описание функции системы с точки зрения конечного пользователя, записанное по шаблону: «Как `роль`, я хочу `цель`, чтобы `выгода`»;
- **Wireframe** — схематичный, упрощённый чёрно-белый макет экрана или страницы, показывающий расположение основных элементов без дизайна.

---

### **Общая информация**

**Системный аналитик (СА)** — специалист, который изучает бизнес-процессы и потребности заказчика (пользователя), выявляет проблемы и возможности, а затем проектирует оптимальное IT-решение (систему, приложение, доработку), выступая ключевым связующим звеном между бизнесом и IT-командой. 

### **Обязанности**

1. Работа с требованиями (основная компетенция):
    - выявление и сбор — проведение интервью, опросов, мозговых штурмов с заказчиками, пользователями, экспертами предметной области. Анализ существующей документации, систем и процессов;
    - анализ и структурирование — обработка собранной, часто хаотичной, информации. Разделение требований на типы, выявление противоречий, «серых зон» и скрытых потребностей;
    - детализация и спецификация — превращение пожеланий в чёткие, однозначные, тестируемые формулировки. Ответы на вопросы «Что?», «Для кого?», «При каких условиях?», «С какими даными?»;
    - валидация и согласование — проверка, правильно ли поняты требования, с заказчиком. Убеждение, что все участники (бизнес, разработка, дизайн) имеют одинаковое видение.

2. Моделирование и проектирование:
    - описание бизнес-процессов — создание схем (в нотациях BPMN, EPC) того, как работает бизнес «до» и «как должно работать после» внедрения системы;
    - проектирование данных — разработка моделей данных (ER-диаграммы), определение сущностей (например, «Заказ», «Клиент», «Товар»), их аттрибутов и связей между ними;
    - проектирование интерфейсов и логики — создание прототипов (wireframes, mockups) экранов в Figma или аналогах. Описание бизнес-логики и сценариев использования системы (Use Case, пользовательские истории, диаграммы UML).

3. Работа с документацией — разработка основных артефактов:
      - бизнес-требования (BRD) / видение продукта (Vision) — зачем мы это делаем, какие бизнес-цели преследуем?
      - техническое задание (ТЗ) / спецификация требований к ПО (SRS / FRS) — детальное, пошаговое описание *что* должна делать система;
      - пользовательские истории и сценарии (User Stories, Use Cases) — описание функциональности с точки зрения пользователя;
      - глоссарий — единый словарь терминов проекта.
> Впоследствии необходимо поддерживать актуальность документации при изменениях в требованиях.

4. Коммуникация и координация (ключевые soft-skills):
    - мост между бизнесом и разработкой — постоянный диалог с обеими сторонами, перевод бизнес-языка на технический и наоборот;
    - управление ожиданиями:
        - объяснение бизнесу, что технически сложно, долго или дорого;
        - объяснение команде разработки, почему та или иная функция критически важна для бизнеса.
    - участие в процессах разработки — работа в Agile-команде (Scrum, Kanban) — участие в планировании, ежедневных встречах, демонстрациях результатов;
    - решение конфликтов — поиск компромиссов между желаниями заказчика, техническими возможностями и сроками.

5. Сопровождение реализации и внедрения:
    - разъяснение требований команде — ответы на вопросы разработчиков и тестировщиков в течение всего цикла;
    - приемочное тестирование (UAT) — помощь бизнес-пользователям в проверке, соответствует ли готовый продукт исходным требованиям. Подписание акта о приемке;
    - анализ проблем после запуска — исследование инцидентов, поиск корневых причин (было ли это деффектом реализации или ошибкой в изначальных требованиях).

Главный результат работы хорошего СА — это не просто папка с документами, а **корректно реализованная система**, которая решает конкретные бизнес-задачи пользователей и приносит ценность.

> Ошибка СА на этапе анализа может привести к созданию того, что никому не нужно, и к потере больших денег и времени.

---

## **2. Жизненный цикл разработки ПО**

### **Глоссарий**

- **Acceptance Criteria (критерии приёмки)** — чёткий и проверяемый список условий, которым должно соответствовать выполнение пользовательской истории или задачи, чтобы она считалась завершенной и удовлетворяющей потребностям пользователя;
- **PO (Product Owner)** — ключевая роль в Scrum, которая отвечает за максимизацию ценности продукта, управление бэклогом и принятие решений о том, что будет сделано в следующем спринте;
- **User Story** — краткое описание функции системы с точки зрения конечного пользователя, записанное по шаблону: «Как `роль`, я хочу `цель`, чтобы `выгода`»;
- **методология** — система принципов, подходов и практик, которые определяют общий стиль и философию работы над проектами;
- **фреймворк** — конкретная реализация методологии, набор готовых правил, артефактов и процессов для организации работы (например, Scrum — это фреймворк внутри методологии Agile).

### **Общая информация**

**Software Development Life Cycle (SDLC)** — это структурированный процесс, который описывает этапы создания программного обеспечения от идеи до списания. Его цель — повысить качество, предсказуемость и управляемость разработки.

Две основные философии управления этим циклом: **каскадная (Waterfall)** и **адаптивная (Agile)**.

### **Каскадная модель (Waterfall)**

Строго **последовательный** подход, где следующий этап начинается только после полного завершения предыдущего. Изменения требований на поздних этапах очень болезненны.

> Простая аналогия — строительство капитального дома. 

> 1. Создание полного проекта со всеми чертежами и сметой.
> 2. Последовательное выполнение этапов: фундамент → стены → крыша → отделка. 
> 3. Вернуться назад и изменить фундамент после возведения стен крайне дорого и сложно.

Типичные фазы:

1.  Сбор и анализ требований (фиксируется подробное ТЗ).
2.  Проектирование (архитектура системы, дизайн).
3.  Разработка (кодирование).
4.  Тестирование.
5.  Внедрение и поддержка.

Используется для:

- проектов с чёткими, неизменными требованиями (например, разработка ПО для банкоматов, систем безопасности);
- жёстких условий регуляторики (медицина, авиация), где каждый шаг должен быть задокументирован;
- работы по фиксированному государственному контракту с жёстким ТЗ.

---

### **Гибкая методология (Agile) и фреймворк Scrum**

**Итеративный** и **инкрементальный** подход. Разработка ведётся короткими циклами (итерациями), в конце каждого из которых заказчик получает работающий кусочек продукта и может дать обратную связь, что приводит к постоянным корректировкам.

> Простая аналогия — выращивание сада. 

> Сад не строится раз и навсегда. 

> - сажаются семена (основные функции);
> - постояная поливка;
> - анализ, что растёт лучше;
> - подрезание;
> - добавление новых растений и смена ландшафта в зависимости от сезона и предпочтений.

**Scrum** — самый популярный *фреймворк* для реализации Agile-подхода. Он задаёт конкретные роли, артефакты и события.

**Ключевые понятия Scrum:**

1. **Спринт** — сердце Scrum, фиксированный по времени цикл работы (обычно 2–4 недели), в течение которого команда создаёт готовый к использованию инкремент продукта (новую версию с добавленной функциональностью). По итогам спринта функциональность демонстрируется заказчику. После одного спринта сразу начинается следующий.
2. **Бэклог продукта** — единый, приоритизированный список всего, что может понадобиться в продукте. Им управляет PO, постоянно его обновляя и пересортировывая. В бэклоге хранятся:
    - функциональные требования (в виде User Story);
    >  User Story — основная единица работы в бэклоге. 
    - критерии приемки (Acceptance Criteria);
    - технические задачи;
    - баги и улучшения;
    - исследовательские задачи.


Отлично, это фундаментальная классификация. Разберём подробно, добавив примеры и характеристики.

---

## **3. Иерархия требований: от стратегии к деталям**

### **Глоссарий**

- **BR (Business Requirements)** — ;
- **BRD** —;
- **FR (Functional Requirements)** — ;
- **FURPS+** — 
- **NFR (Non-Functional Requirements)** — 
- **SRS (Software Requirements Specification) / FRS (Functional Requirements Specification)** — детальный документ, описывающий функциональные и нефункциональные требования к системе, её поведение и интерфейсы;

### **Общая информация**

Стратегия → Что делает система → Качество и ограничения

### **Бизнес-требования (BR)**

Отвечают на вопрос — **зачем**, **какую** бизнес-цель, проблему или возможность закрыть этим проектом/продуктом.

Основы:

- уровень — стратегический, самый высокоуровневый;
- целевая аудитория — руководство компании, заказчики, инвесторы;
- формулировки — часто выражаются в терминах увеличения прибыли, снижения затрат, роста рынка, повышения удовлетворенности клиентов;
- ключевой документ — видение продукта, бизнес-требования (BRD).

    ??? "Пример"
            Система должна:
                1. Увеличить число заказов на 20% в течение года.
                2. Выйти на окупаемость проекта за 18 месяцев.
                3. Повысить лояльность пользователей (удержание) с 30% до 50%.
                4. Сократить расходы на кол-центр на 15% за счет автоматизации.

### **Функциональные требования (FR)**

Отвечают на вопрос — **что** конкретно система должна делать, какие функции выполнять.

Основы:

- уровень — тактический, уровень поведения системы;
- целевая аудитория — системные аналитики, разработчики, тестировщики;
- формулировки — описывают поведение системы в ответ на действия пользователя или другие события, часто начинаются с «Система должна...»;
- ключевой документ — спецификация требований к ПО (SRS/FRS), пользовательские истории.

    ??? "Пример"
            Система должна:
                - позволять пользователю ввести адрес назначения;
                - рассчитывать и отображать предварительную стоимость поездки;
                - показывать на карте положение назначенного водителя в реальном времени;
                - отправлять пользователю push-уведомление о прибытии машины.


### **Нефункциональные требования (NFR)**
Отвечают на вопрос — **какими** качествами и свойствами должна обладать система, в каких условиях работать?

Основы:

- уровень — тактический и технический, уровень атрибутов качества;
- целевая аудитория — архитекторы, разработчики, DevOps, тестировщики производительности;
- формулировки — описывают **ограничения** и **характеристики** работы системы, часто измеримы;
- ключевой документ — спецификация требований к ПО (SRS), отдельный раздел по атрибутам качества.

#### **Основные категории NFR (FURPS+) для примеров:**

- **производительность (Performance):**
    - 95% всех запросов к API должны обрабатываться менее чем за 500 мс;
    - приложение должно запускаться на мобильном устройстве менее чем за 2 секунды.
- **масштабируемость (Scalability)** — система должна выдерживать до 10 000 одновременных активных пользователей;
- **безопасность (Security):**
    - все пароли должны храниться в захэшированном виде;
    - доступ к панели администратора разрешен только по VPN.
- **надёжность/доступность:**
    - время безотказной работы (uptime) системы должно составлять 99.9%;
    - в случае сбоя восстановление работы должно занимать не более 15 минут.
- **удобство использования:**
    - новый пользователь должен совершить первую поездку без обращения в справку;
    - интерфейс должен быть локализован на 3 языка.
- **сопровождаемость (Maintainability)** — код должен быть покрыт юнит-тестами минимум на 80%.
- **совместимость** — приложение должно работать на iOS 14+ и Android 10+.

> Несоблюдение NFR (например, медленная работа или постоянные падения) может привести к полному провалу продукта, даже если все функции реализованы. 

> Бизнес-цель («увеличить число заказов») не будет достигнута, если пользователи удалят зависающее приложение.




## **5. UML-диаграммы и BPMN-нотации**

### **Глоссарий**

### **Общая информация**

### **UML-диаграммы**

UML (Unified Modeling Language) — стандартизированный язык графического моделирования для спецификации, визуализации, проектирования и документирования архитектуры программных систем.

Диаграммы делятся на:

- структурные — **что** в системе есть;
- поведенческие — **как** система работает.

#### **Структурные диаграммы**

##### **Диаграмма классов (Class Diagram)**

- показывает статическую структуру системы — классы, их атрибуты, методы и связи;
- элементы — класс (прямоугольник с 3 секциями: имя, атрибуты, методы), связи (ассоциация, агрегация, композиция, наследование).

??? "Class Diagram"

    ``` mermaid
        classDiagram
    direction LR
    class Customer {
        -id: int
        -name: string
        -email: string
        -phone: string
        +register()
        +placeOrder() Order
        +getOrderHistory() Order[]
    }
    
    class Order {
        -orderId: int
        -date: DateTime
        -status: string
        -totalAmount: decimal
        +create()
        +calculateTotal()
        +cancel()
        +updateStatus()
    }
    
    class Product {
        -productId: int
        -name: string
        -description: string
        -price: decimal
        -stockQuantity: int
        +updateStock()
        +getAvailability() bool
    }
    
    class OrderItem {
        -quantity: int
        -unitPrice: decimal
        +calculateSubtotal() decimal
    }
    
    Customer "1" --> "0..*" Order : places
    Order "1" --> "1..*" OrderItem : contains
    OrderItem "1" --> "1" Product : references
    
    class Payment {
        <<abstract>>
        -amount: decimal
        -date: DateTime
        +process() bool
    }
    
    class CreditCardPayment {
        -cardNumber: string
        -expiryDate: string
        -cvv: string
        +validateCard() bool
        +process() bool
    }
    
    class PayPalPayment {
        -email: string
        +process() bool
    }
    
    Payment <|-- CreditCardPayment
    Payment <|-- PayPalPayment
    Order "1" --> "1" Payment : has
    ```

##### **Диаграмма компонентов (Component Diagram)**

- показывает физические компоненты системы (модули, библиотеки, файлы) и их зависимости;
- используется для проектирования архитектуры.

??? "Component Diagram"



    ``` mermaid
    graph TD
    subgraph "Платформа электронной коммерции"
        UI[Web Interface] --> API[API Gateway]
        
        subgraph "Бизнес-сервисы"
        API --> Auth[Authentication Service]
        API --> Catalog[Product Catalog]
        API --> Order[Order Service]
        API --> Payment[Payment Service]
        end
        
        subgraph "Инфраструктура"
        DB1[(Customer DB)]
        DB2[(Product DB)]
        DB3[(Order DB)]
        Cache[(Redis Cache)]
        Queue[(Message Queue)]
        end
        
        Auth --> DB1
        Catalog --> DB2
        Order --> DB3
        Payment --> Queue
        Order --> Cache
    end
    
    External[External Payment Gateway] <--> Payment
    ```

##### **Диаграмма развёртывания (Deployment Diagram)** 

Показывает физическое размещение компонентов на серверах и оборудовании.

??? "Deployment Diagram"

    ``` mermaid
    graph TB
    subgraph "Облачный провайдер AWS"
        subgraph "VPC: 10.0.0.0/16"
        subgraph "Public Subnet A"
            LB[Application Load Balancer<br/>ALB]
        end
        
        subgraph "Private Subnet A"
            App1[App Server 1<br/>t3.medium]
            App2[App Server 2<br/>t3.medium]
        end
        
        subgraph "Private Subnet B"
            DB1[Primary Database<br/>RDS PostgreSQL]
            DB2[Read Replica<br/>RDS PostgreSQL]
        end
        
        subgraph "Private Subnet C"
            Cache[ElastiCache Redis]
            Queue[SQS Queue]
        end
        end
    end
    
    Internet --> LB
    LB --> App1
    LB --> App2
    App1 --> DB1
    App2 --> DB1
    DB1 -.-> DB2
    App1 --> Cache
    App2 --> Cache
    App1 --> Queue
    App2 --> Queue
    
    style LB fill:#e1f5fe
    style App1 fill:#f3e5f5
    style DB1 fill:#e8f5e8
    style Cache fill:#fff3e0
    ```
#### **Поведенческие диаграммы**

##### **Диаграмма вариантов использования (Use Case Diagram)**

- показывает взаимодействие акторов (пользователей, систем) с системой;
- элементы: актор (человечек), вариант использования (овал), связи (ассоциация, include, extend).

??? "Use Case Diagram"

    ``` mermaid
    graph TD
    actor Customer as "Покупатель"
    actor Manager as "Менеджер"
    actor Admin as "Администратор"
    actor System as "Платежная система"
    
    Customer --> Browse[Просмотр каталога]
    Customer --> Search[Поиск товаров]
    Customer --> Cart[Работа с корзиной]
    Customer --> Order[Оформление заказа]
    Customer --> Track[Отслеживание заказа]
    Customer --> Review[Написание отзыва]
    
    Cart --> AddItem[Добавить товар]
    Cart --> RemoveItem[Удалить товар]
    Cart --> UpdateQty[Изменить количество]
    
    Order --> Checkout[Перейти к оплате]
    Checkout --> Payment[Оплата заказа]
    Payment --> System
    
    Manager --> ManageOrders[Управление заказами]
    Manager --> ManageProducts[Управление товарами]
    Manager --> Reports[Просмотр отчетов]
    
    Admin --> UserManagement[Управление пользователями]
    Admin --> SystemConfig[Конфигурация системы]
    Admin --> Backup[Резервное копирование]
    
    ManageOrders -.->|include| ChangeStatus[Изменение статуса]
    ManageOrders -.->|include| ViewDetails[Просмотр деталей]
    
    Payment -.->|extend| ApplyPromo[Применить промокод]
    
    note right of ApplyPromo
        Расширяет основной сценарий оплаты
        при наличии активного промокода
    end note

    ```

##### **Диаграмма последовательности (Sequence Diagram)**

- показывает временную последовательность сообщений между объектами;
- идеальна для описания сложных сценариев взаимодействия

??? "Sequence Diagram"

    ``` mermaid
    sequenceDiagram
    autonumber
    participant User as Пользователь
    participant UI as Веб-интерфейс
    participant Auth as Сервис аутентификации
    participant API as API Gateway
    participant Order as Сервис заказов
    participant Payment as Платежный сервис
    participant Stock as Сервис склада
    participant Notify as Сервис уведомлений
    
    User->>UI: Добавить товар в корзину
    UI->>API: POST /api/cart/add
    API->>Auth: Валидация токена
    Auth-->>API: Успешно (user_id=123)
    API->>Order: Обновить корзину
    Order-->>API: Корзина обновлена
    API-->>UI: 200 OK
    UI-->>User: Товар добавлен
    
    User->>UI: Нажать "Оформить заказ"
    UI->>API: POST /api/orders/create
    API->>Order: Создать заказ
    Order->>Stock: Проверить наличие товара
    Stock-->>Order: Товары доступны
    Order->>Stock: Зарезервировать товары
    Stock-->>Order: Товары зарезервированы
    Order-->>API: Заказ создан (id=456)
    
    API->>Payment: Создать платеж
    Payment-->>API: Ссылка на оплату
    API-->>UI: Данные для оплаты
    UI-->>User: Переход на страницу оплаты
    
    User->>Payment: Оплатить заказ
    Payment-->>User: Подтверждение оплаты
    Payment->>Order: Обновить статус на "Оплачен"
    Order->>Stock: Подтвердить резервирование
    Order->>Notify: Отправить уведомление
    Notify-->>User: Email с подтверждением

    ```

##### **Диаграмма состояний (State Machine Diagram)**

- показывает жизненный цикл объекта — состояния и переходы между ними;
- отлично подходит для документирования статусов заказов, документов.

??? "State Machine Diagram"

    ``` mermaid
    stateDiagram-v2
    [*] --> Новый
    
    Новый --> Проверка : submit()
    Проверка --> Одобрен : approve()
    Проверка --> Отклонен : reject()
    
    Одобрен --> ВПроцессе : startProcessing()
    ВПроцессе --> НаПаузе : pause()
    НаПаузе --> ВПроцессе : resume()
    
    ВПроцессе --> Завершен : complete()
    Завершен --> [*]
    
    Отклонен --> [*]
    
    state Проверка {
        [*] --> ПроверкаДанных
        ПроверкаДанных --> Верификация
        Верификация --> [*]
    }
    
    note right of Проверка
        Включает проверку
        данных и верификацию
    end note
    ```

##### **Диаграмма деятельности (Activity Diagram)**

- похожа на блок-схему, но с расширенными возможностями (параллельные потоки, дорожки);
- часто используется для описания бизнес-процессов.

??? "Activity Diagram"

    ``` mermaid
    flowchart TD
    A([Начало процесса]) --> B[Пользователь открывает форму]
    B --> C{Все обязательные поля заполнены?}
    C -->|Нет| D[Показать ошибки валидации]
    D --> B
    C -->|Да| E[Отправить данные на сервер]
    
    subgraph F [Обработка на сервере]
        direction LR
        F1[Проверка данных] --> F2[Валидация бизнес-правил] --> F3[Сохранение в БД]
    end
    
    E --> F
    F --> G{Сохранение успешно?}
    G -->|Нет| H[Записать ошибку в лог]
    H --> I[Вернуть ошибку клиенту]
    I --> J[Показать сообщение об ошибке]
    
    G -->|Да| K[Создать связанные записи]
    K --> L[Отправить email-подтверждение]
    L --> M[Обновить кеш]
    M --> N[Показать сообщение об успехе]
    
    J --> O([Конец процесса])
    N --> O
    
    style A fill:#c8e6c9
    style O fill:#ffcdd2

    ```

> Когда использовать UML:

> - проектирование архитектуры (диаграммы классов, компонентов);
> - анализ требований (use case, последовательности);
> - описание сложной логики (состояний, последовательностей);
> - коммуникация с разработчиками (все диаграммы UML — их родной язык).
